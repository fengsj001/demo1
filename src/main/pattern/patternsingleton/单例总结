单例模式汇总：

单例模式应用场景：
    单例模式（singleton pattern）是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。单例模式是创建模式。
单例模式常见写法：
    为了解决并发访问的时候线程安全问题，保证单例的技术方案有很多种：饿汉式，懒汉式，注册登记式。
    1、饿汉式
    饿汉式单例是在加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线程还没出现以前就实例化了，不可能存在访问安全问题。
    优点：没有加任何的锁、执行效率比较高，在用户体验上来说比懒汉式更好。
    缺点：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存。
    2、懒汉式
    懒汉式单例的特点是：被外部类调用的时候内部类才会加载。默认加载的时候不实例化，在需要用这个实例的时候才实例化，延时加载。一共有五种情况：不加锁的情况，方法加锁，匿名内部类的形式，变量上加锁
    （DCL双检锁）， volatile终极版本
    优点：第一次调用时才会初始化，避免内存浪费
    缺点：必须加锁synchronized才能保证单例
    3、注册登记式
    就是将每一个势力都登记到某一个地方，使用唯一的标识获取实例。注册式单例有两种写法：一种为容器缓存，一种为枚举登记。
    优点：拥有饿汉和懒汉的优点，并且屏蔽了他们的缺点，效率高，延时加载，并且线程安全。
    缺点：代码复杂度较前两种高

    破坏单例模式的方式
    所谓单例模式就是某一个类只能有一个实例，实现的核心就是将该类的构造函数私有化，只能由该类创建对象，其他的对象就不能调用该类的构造函数，即不能通过new来创建对象了。但是对象的创建
    有四种方式：new、克隆、序列化、反射。如果通过其他三种方式创建对象，就会破坏了单例模式。
    破坏单例模式的方式有：克隆、反射和序列化。
    克隆
    如果累实现了cloneable接口，尽管构造函数是私有的，他也可以创建一个对象。即clone方法是不会调用构造函数的，他是直接从内存中copy内存区域的。
    解决方法：
    单例模式的类不实现cloneable接口。
    反射
    反射是可以获取类的构造函数，再加一行setAccessible（true）；就可以调用私有的构造函数，创建对象了。
    解决方法：
    当第二次调用构造函数时抛出异常。
    序列化
    一是可以实现数据的持久化；二是可以对象数据的远程传输。如果过该类imples serializable，那么久会在反序列化的过程中再创建一个对象。
    解决方法：
    在反序列化时，指定反序列化的对象实例。即只要在Singleton类中定义readResovle就可以解决该问题。

    内部类的执行逻辑
    类加载时不会加载内部类，只有其静态成员被调用的时候才会加载。
